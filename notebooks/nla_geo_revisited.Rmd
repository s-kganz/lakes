---
title: "Geologic Context of NLA Lakes, Revisited"
author:
- Keenan Ganz
output:
  pdf_document:
    extra_dependencies: ["booktabs"]
bibliography: bibliography.bib
csl: american-institute-of-physics.csl
---

```{r setup, echo=F, message=F}
knitr::opts_knit$set(root.dir = normalizePath(".."))
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
```
```{r libraries}
library(igraph)
library(sf)
library(tidyverse)
library(caret)
library(randomForest)
library(factoextra)
library(FactoMineR)
library(cooccur)
library(visNetwork)
library(ggridges)
```

# Introduction
In `01_nla_geo.pdf`, we looked at a dataset of surficial geology and determined whether the parent sediment types had any predictive power on lake depth. We found that the predictive power was overall quite low ($R^2 \approx 0.1$), but we did see interesting cooccurrence of sediments according to a physical process. For example, we saw that glacial sediments sorted themselves by grain size.

The source dataset for that notebook was part of a larger publication on landforms for climate adaptation planning[@theobaldEcologicallyRelevantMapsLandforms2015]. That raster was in turn derived from surficial material mapping undertaken by the US Geologic Survey[@sollerMapDatabaseSurficial2009]. Although surficial materials are ecologically important, they may not have as large an impact on terrain morphology as underlying bedrock. This notebook will revisit the analysis from the first notebook with the State Geologic Map Compilation[@hortonStateGeologicMap2017].

# Methods
## SGMC Characteristics
The SGMC is a compilation of state geologic maps. As such, the SGMC is not standardized across state boundaries. There are five nested levels of lithology categories. We only consider the primary and secondary categories, which are listed below.

\begin{center}
\begin{tabular}{ll}
\toprule
Primary Category & Secondary Category\\
\midrule
Sedimentary & Carbonate\\
 & Chemical\\
 & Clastic\\
 & Coal\\
\addlinespace
Igneous & Plutonic\\
 & Volcanic\\
 & Hypabyssal\\
\addlinespace
Metamorphic & Metaigneous\\
 & Gneiss\\
 & Granoblastic\\
 & Schist\\
 & Metasedimentary\\
 & Amphibolite\\
 & Migmatite\\
 & Hydrothermally-altered\\
 & Granulite\\
\addlinespace
Tectonite & Melange\\
 & Mylonite\\
\addlinespace
Unconsolidated & Fine-detrital\\
 & Coarse-detrital\\
 & Peat\\
 & Marl\\
\bottomrule
\end{tabular}
\end{center}

The SGMC is desirable because of its nested design. The schema is also designed from a geologic perspective.

## Spatial Analysis
As in the previous notebook, we begin with sampled lake polygons from the 2007 and 2012 EPA National Lakes Assessment[@usepa2012NationalLakes]. Duplicates across the two sampling campaigns were removed, and the polygon was buffered by 1km. Both of these datasets were uploaded to Google Earth Engine[@gorelickGoogleEarthEngine2017a]. SGMC polygons were rasterized to 50m cell size and the relative areal cover of each lithology category was computed.

## Cooccurrence Analysis
To determine if certain lithology categories are more likely to cooccur in the 1km buffer region around each lake, we used the species cooccurrence model implemented in the R package `cooccur`[@veechProbabilisticModelAnalysing2013].

# Results
```{r lith-tables}
sgmc_primary_names <- list(
  "primary_lith_type1"="Igneous",
  "primary_lith_type2"="Sedimentary",
  "primary_lith_type3"="Unconsolidated",
  "primary_lith_type5"="Metamorphic",
  "primary_lith_type6"="Tectonite"
) %>% data.frame() %>%
  pivot_longer(everything(), names_to="gee_name", values_to="sgmc_name")

sgmc_secondary_names <- list(
  "secondary_lith_type1"="Plutonic",
  "secondary_lith_type2"="Carbonate",
  "secondary_lith_type3"="Chemical",
  "secondary_lith_type4"="Clastic",
  "secondary_lith_type5"="Fine-detrital",
  "secondary_lith_type6"="Coarse-detrital",
  "secondary_lith_type8"="Volcanic",
  "secondary_lith_type9"="Metaigneous",
  "secondary_lith_type10"="Gneiss",
  "secondary_lith_type11"="Melange",
  "secondary_lith_type12"="Granoblastic",
  "secondary_lith_type13"="Schist",
  "secondary_lith_type14"="Metasedimentary",
  "secondary_lith_type15"="Hypabyssal",
  "secondary_lith_type16"="Amphibolite",
  "secondary_lith_type17"="Coal",
  "secondary_lith_type18"="Migmatite",
  "secondary_lith_type19"="Peat",
  "secondary_lith_type20"="Hydrothermally-altered",
  "secondary_lith_type21"="Marl",
  "secondary_lith_type22"="Mylonite",
  "secondary_lith_type23"="Granulite"
) %>% data.frame() %>% 
  pivot_longer(everything(), names_to="gee_name", values_to="sgmc_name")

sgmc_crosswalk <- read_csv("data_out/sgmc_crosswalk.csv") %>%
  select(name, parent) %>% filter(!is.na(parent))
```
```{r read-data}
nla <- read_csv("data_out/nla_terrain_gee.csv") %>%
  select(NLAID, maxdepth)

sgmc_primary <- read_csv("data_working/sgmc_primary.csv")
sgmc_secondary <- read_csv("data_working/sgmc_secondary.csv")

# add prefixes
primary_colnames <- colnames(sgmc_primary)[2:ncol(sgmc_primary)]
primary_colnames <- paste("primary_", primary_colnames, sep="")
colnames(sgmc_primary)[2:ncol(sgmc_primary)] <- primary_colnames

secondary_colnames <- colnames(sgmc_secondary)[2:ncol(sgmc_secondary)]
secondary_colnames <- paste("secondary_", secondary_colnames, sep="")
colnames(sgmc_secondary)[2:ncol(sgmc_secondary)] <- secondary_colnames

# join with NLA data
nla_lith <- nla %>%
  inner_join(sgmc_primary, by="NLAID") %>%
  inner_join(sgmc_secondary, by="NLAID") %>%
  # drop lakes that didn't intersect any of the polygons
  rowwise() %>%
  mutate(n_seds = sum(c_across(contains("primary")) > 0)) %>%
  filter(n_seds > 0) %>%
  select(-n_seds)
```

## Exploratory Data Analysis
Although constructed in a different way, the SGMC data should hav esimilar characteristics as the previous surficial geology data. Like before, we expect that the majority of lakes are associated with one major geology type.
```{r n-primary-types}
nla_lith %>%
  rowwise() %>%
  mutate(n_seds = sum(c_across(contains("primary")) > 0)) %>%
  ggplot(aes(x=n_seds)) + geom_bar(stat="count") +
  labs(y="Count", x="Number of Primary Lithology Types")
```

```{r n-secondary-types}
nla_lith %>%
  rowwise() %>%
  mutate(n_seds = sum(c_across(contains("secondary")) > 0)) %>%
  ggplot(aes(x=n_seds)) + geom_bar(stat="count") +
  labs(y="Count", x="Number of Secondary Lithology Types")
```

As before, most lakes have 1-2 lithology types. Now, let's see if any category is associated with lake depth. For this, we assign lakes to lithology types by computing the category with the largest areal cover in each polygon. Only two lakes had tectonite as their dominant lithology, so this category was discarded for this section. Likewise, there were few lakes with peat, migmatite, or granulite as the dominant secondary lithology, so these were discarded as well.

```{r calc-dominant-lith}
primary_only <- nla_lith %>% 
  select(contains("primary"), -contains("dominant")) %>%
  as.matrix()
nla_lith$dominant_primary <- colnames(primary_only)[max.col(primary_only)]
nla_lith$dominant_primary <- sgmc_primary_names$sgmc_name[
  match(
    as.character(nla_lith$dominant_primary), 
    as.character(sgmc_primary_names$gee_name))
]

secondary_only <- nla_lith %>% 
  select(contains("secondary"), -contains("dominant")) %>%
  as.matrix()
nla_lith$dominant_secondary <- colnames(secondary_only)[max.col(secondary_only)]
nla_lith$dominant_secondary <- sgmc_secondary_names$sgmc_name[
  match(
    as.character(nla_lith$dominant_secondary), 
    as.character(sgmc_secondary_names$gee_name))
]
```

```{r primary-lith-density}
nla_lith %>%
  filter(dominant_primary != "Tectonite") %>%
  ggplot(aes(y=dominant_primary, x=log(maxdepth))) +
  geom_density_ridges(aes(fill=dominant_primary)) +
  labs(y="", x="Log Maximum Depth", fill="Dominant Primary Lithology") +
  theme(axis.text.y = element_blank())
```
```{r nla-secondary-density}

# everything with <= 3 samples
few_secondary_samples <- c("Peat", "Migmatite", "Granulite",
                           "Hydrothermally-altered",
                           "Melange", "Mylonite")

nla_lith %>%
  filter(!(dominant_secondary %in% few_secondary_samples)) %>%
  inner_join(sgmc_crosswalk %>%
               select(name, parent), 
             by=c("dominant_secondary"="name")) %>%
  rename(dominant_secondary_parent = parent) %>%
  ggplot(aes(y=dominant_secondary, x=log(maxdepth))) +
  geom_density_ridges(aes(fill=dominant_secondary_parent)) +
  labs(y="", x="Log Maximum Depth", fill="Parent Lithology Class")
```
```{r nla-primary-shapiro}
nla_lith_shapiro <- nla_lith %>%
  filter(dominant_primary != "Tectonite") %>%
  group_by(dominant_primary) %>%
  mutate(logmax = log(maxdepth)) %>%
  nest() %>%
  mutate(shapiro.ret = map(data, function(d) {shapiro.test(d$logmax)}))
```

With a log transformation, the distributions appear normal. However, a Shapiro-Wilk non-normality test was significant for each category. Instead, we use the Kruskal-Wallis test as an alternative to a one-way ANOVA. Bear in mind that there is some spatial autocorrelation in the data for lakes that are close together.

```{r nla-primary-kruskal}
nla_primary_kruskal <- nla_lith %>%
  mutate(logmax = log(maxdepth)) %>%
  filter(dominant_primary != "Tectonite") %>%
  kruskal.test(.$logmax, .$dominant_primary)
```

The test has $p = $ `r round(nla_primary_kruskal$p.value, 2)`. This is significant, so this may indicate that lithology plays a role in determining maximum lake depth. However, the distributions in the above density ridges plot appear quite similar. So, the predictive power is probably poor.

## Cooccurrence Analysis
If cooccurring sediments align into clusters, we may be able to split lakes by their environment. 

```{r cooccurrence-matrix}
nla_lith_cooccur <- nla_lith %>%
  drop_na() %>%
  select(contains("secondary_lith_type")) %>%
  mutate_all(ceiling) %>%
  as.matrix() %>%
  t()

# recode the row names
rownames(nla_lith_cooccur) <- sgmc_secondary_names$sgmc_name[
  match(rownames(nla_lith_cooccur), sgmc_secondary_names$gee_name)
]

nla_model <- cooccur(nla_lith_cooccur, type="spp_site", spp_names=T)
plot(nla_model) + ggtitle("Secondary Lithology Co-occurrence Matrx")
```

```{r lith-network}
# adapted from https://medium.com/analytics-vidhya/
# how-to-create-co-occurrence-networks-with-the-r-
# packages-cooccur-and-visnetwork-f6e1ceb1c523
nodes <- data.frame(
  id=1:nrow(nla_lith_cooccur),
  label=rownames(nla_lith_cooccur),
  color = "#4287f5"
)

edges <- data.frame(from = nla_model$results$sp1, to = nla_model$results$sp2,
      color = ifelse(nla_model$results$p_lt <= 0.05, "#B0B2C1", "#3C3F51"),
      p_gt = nla_model$results$p_gt
) %>%
  filter(p_gt < 0.05)

# cannot export directly in a notebook
#visNetwork(nodes, edges)
```

Several metamorphic secondary lithologies cluster together while the majority of secondary lithologies are disconnected. Does the single cluster have a different depth?

```{r metamorphic-cluster}
metamorphic_cluster <- c("Plutonic", "Amphibolite", "Schist", "Metaigneous", "Metasedimentary", "Gneiss")
# rename back to the gee name so we can easily look it up
metamorphic_cluster <- sgmc_secondary_names$gee_name[
  match(metamorphic_cluster, sgmc_secondary_names$sgmc_name)
]

nla_lith %>%
  mutate(in_meta_cluster = sum(c_across(metamorphic_cluster)) > 0) %>%
  ggplot(aes(x=maxdepth, y=in_meta_cluster)) +
  geom_density_ridges(aes(fill=in_meta_cluster)) +
  theme(axis.text.y=element_blank()) +
  labs(x="Maximum Lake Depth (m)", y="",
       fill="In Metamorphic Cluster")

```

```{r metamorphic-cluster-kruskal}
metamorphic_cluster_kruskal <- nla_lith %>%
  mutate(in_meta_cluster = sum(c_across(metamorphic_cluster)) > 0) %>%
  kruskal.test(.$maxdepth, .$in_meta_cluster)
```

Lakes that are in the metamorphic cluster have a longer upper tail than those lakes outside of the cluster. This difference is significant according to a Kruskal-Wallis rank sum test ($p < 10^{-3}$).

## Random Forest Modeling

Finally, we consider the use of random forest in predicting maximum lake depth. Since the lithology types are nested, we used only the secondary categories to form this model.

```{r secondary-rf}
nla_lith_rf <- nla_lith %>%
  select(maxdepth, contains("secondary_lith_type"))

trainInd <- sample(1:nrow(nla_lith_rf),
                   (nrow(nla_lith_rf) * 0.8) %>% round())

rf_train <- nla_lith_rf[ trainInd, ]
rf_valid <- nla_lith_rf[-trainInd, ]

trControl <- trainControl(
  method="repeatedcv",
  number=3,
  repeats=3
)

# random search of model parameters
rf_model <- train(
  maxdepth ~ .,
  data=rf_train,
  method="rf",
  metric="RMSE",
  tuneLength=5,
  trControl=trControl
)

rf_valid$predicted <- predict(rf_model, rf_valid)
valid_rmse <- sqrt(mean((rf_valid$predicted - rf_valid$maxdepth) ^ 2))
ggplot(rf_valid, aes(x=maxdepth, y=predicted)) +
  geom_abline(slope=1, intercept=0, color="red", size=2, linetype="dashed") + 
  geom_point() + coord_equal() + ylim(0, 60) +
  labs(y="Predicted Maximum Depth (m)", x="Actual Maximum Depth (m)")
```

This model had an $R^2$ of `r round(rf_model$results$Rsquared[1], 2)` and RMSE of `r round(rf_model$results$RMSE[1], 2)`m.

# Conclusions

As with the previous geologic dataset, we uncovered minor differences in lake depth along lithologic categories. Some cooccurrence structures were identified, but these did not give any more predictive power than the previous dataset.

# References